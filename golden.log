1w> starting: python3 solutions/interpret_week3.py 'jpamb.cases.Simple.assertBoolean:(Z)V' '(false)'
1w> read decompiled classfile decompiled/jpamb/cases/Simple.json
1w> STEP 0:
1w>   PC: 0 {'field': {'class': 'jpamb/cases/Simple', 'name': '$assertionsDisabled', 'type': 'boolean'}, 'offset': 0, 'opr': 'get', 'static': True}
1w>   LOCALS: [False]
1w>   STACK: []
1w> STEP 1:
1w>   PC: 1 {'condition': 'ne', 'offset': 3, 'opr': 'ifz', 'target': 8}
1w>   LOCALS: [False]
1w>   STACK: [False]
1w> STEP 2:
1w>   PC: 2 {'index': 0, 'offset': 6, 'opr': 'load', 'type': 'int'}
1w>   LOCALS: [False]
1w>   STACK: []
1w> STEP 3:
1w>   PC: 3 {'condition': 'ne', 'offset': 7, 'opr': 'ifz', 'target': 8}
1w>   LOCALS: [False]
1w>   STACK: [False]
1w> STEP 4:
1w>   PC: 4 {'class': 'java/lang/AssertionError', 'offset': 10, 'opr': 'new'}
1w>   LOCALS: [False]
1w>   STACK: []
1w> STEP 5:
1w>   PC: 5 {'offset': 13, 'opr': 'dup', 'words': 1}
1w>   LOCALS: [False]
1w>   STACK: ['new java/lang/AssertionError()']
1w> STEP 6:
1w>   PC: 6 {'access': 'special', 'method': {'args': [], 'is_interface': False, 'name': '<init>', 'ref': {'kind': 'class', 'name': 'java/lang/AssertionError'}, 'returns': None}, 'offset': 14, 'opr': 'invoke'}
1w>   LOCALS: [False]
1w>   STACK: ['new java/lang/AssertionError()', 'new java/lang/AssertionError()']
1w> STEP 7:
1w>   PC: 7 {'offset': 17, 'opr': 'throw'}
1w>   LOCALS: [False]
1w>   STACK: ['assertion error', 'new java/lang/AssertionError()']
1w> STEP 8:
1w>   PC: 8 {'offset': 18, 'opr': 'return', 'type': None}
1w>   LOCALS: [False]
1w>   STACK: ['assertion error', 'new java/lang/AssertionError()']
1w> DONE ok
1w>   LOCALS: [False]
1w>   STACK: ['assertion error', 'new java/lang/AssertionError()']
1w> done
QC> starting: python3 solutions/interpret_week3.py 'jpamb.cases.Simple.assertBoolean:(Z)V' '(true)'
QC> read decompiled classfile decompiled/jpamb/cases/Simple.json
QC> STEP 0:
QC>   PC: 0 {'field': {'class': 'jpamb/cases/Simple', 'name': '$assertionsDisabled', 'type': 'boolean'}, 'offset': 0, 'opr': 'get', 'static': True}
QC>   LOCALS: [True]
QC>   STACK: []
QC> STEP 1:
QC>   PC: 1 {'condition': 'ne', 'offset': 3, 'opr': 'ifz', 'target': 8}
QC>   LOCALS: [True]
QC>   STACK: [False]
QC> STEP 2:
QC>   PC: 2 {'index': 0, 'offset': 6, 'opr': 'load', 'type': 'int'}
QC>   LOCALS: [True]
QC>   STACK: []
QC> STEP 3:
QC>   PC: 3 {'condition': 'ne', 'offset': 7, 'opr': 'ifz', 'target': 8}
QC>   LOCALS: [True]
QC>   STACK: [True]
QC> STEP 4:
QC>   PC: 8 {'offset': 18, 'opr': 'return', 'type': None}
QC>   LOCALS: [True]
QC>   STACK: []
QC> DONE ok
QC>   LOCALS: [True]
QC>   STACK: []
QC> done
mt> starting: python3 solutions/interpret_week3.py 'jpamb.cases.Simple.assertFalse:()V' '()'
mt> read decompiled classfile decompiled/jpamb/cases/Simple.json
mt> STEP 0:
mt>   PC: 0 {'field': {'class': 'jpamb/cases/Simple', 'name': '$assertionsDisabled', 'type': 'boolean'}, 'offset': 0, 'opr': 'get', 'static': True}
mt>   LOCALS: []
mt>   STACK: []
mt> STEP 1:
mt>   PC: 1 {'condition': 'ne', 'offset': 3, 'opr': 'ifz', 'target': 6}
mt>   LOCALS: []
mt>   STACK: [False]
mt> STEP 2:
mt>   PC: 2 {'class': 'java/lang/AssertionError', 'offset': 6, 'opr': 'new'}
mt>   LOCALS: []
mt>   STACK: []
mt> STEP 3:
mt>   PC: 3 {'offset': 9, 'opr': 'dup', 'words': 1}
mt>   LOCALS: []
mt>   STACK: ['new java/lang/AssertionError()']
mt> STEP 4:
mt>   PC: 4 {'access': 'special', 'method': {'args': [], 'is_interface': False, 'name': '<init>', 'ref': {'kind': 'class', 'name': 'java/lang/AssertionError'}, 'returns': None}, 'offset': 10, 'opr': 'invoke'}
mt>   LOCALS: []
mt>   STACK: ['new java/lang/AssertionError()', 'new java/lang/AssertionError()']
mt> STEP 5:
mt>   PC: 5 {'offset': 13, 'opr': 'throw'}
mt>   LOCALS: []
mt>   STACK: ['assertion error', 'new java/lang/AssertionError()']
mt> STEP 6:
mt>   PC: 6 {'offset': 14, 'opr': 'return', 'type': None}
mt>   LOCALS: []
mt>   STACK: ['assertion error', 'new java/lang/AssertionError()']
mt> DONE ok
mt>   LOCALS: []
mt>   STACK: ['assertion error', 'new java/lang/AssertionError()']
mt> done
Nb> starting: python3 solutions/interpret_week3.py 'jpamb.cases.Simple.assertInteger:(I)V' '(0)'
Nb> read decompiled classfile decompiled/jpamb/cases/Simple.json
Nb> STEP 0:
Nb>   PC: 0 {'field': {'class': 'jpamb/cases/Simple', 'name': '$assertionsDisabled', 'type': 'boolean'}, 'offset': 0, 'opr': 'get', 'static': True}
Nb>   LOCALS: [0]
Nb>   STACK: []
Nb> STEP 1:
Nb>   PC: 1 {'condition': 'ne', 'offset': 3, 'opr': 'ifz', 'target': 8}
Nb>   LOCALS: [0]
Nb>   STACK: [False]
Nb> STEP 2:
Nb>   PC: 2 {'index': 0, 'offset': 6, 'opr': 'load', 'type': 'int'}
Nb>   LOCALS: [0]
Nb>   STACK: []
Nb> STEP 3:
Nb>   PC: 3 {'condition': 'ne', 'offset': 7, 'opr': 'ifz', 'target': 8}
Nb>   LOCALS: [0]
Nb>   STACK: [0]
Nb> STEP 4:
Nb>   PC: 4 {'class': 'java/lang/AssertionError', 'offset': 10, 'opr': 'new'}
Nb>   LOCALS: [0]
Nb>   STACK: []
Nb> STEP 5:
Nb>   PC: 5 {'offset': 13, 'opr': 'dup', 'words': 1}
Nb>   LOCALS: [0]
Nb>   STACK: ['new java/lang/AssertionError()']
Nb> STEP 6:
Nb>   PC: 6 {'access': 'special', 'method': {'args': [], 'is_interface': False, 'name': '<init>', 'ref': {'kind': 'class', 'name': 'java/lang/AssertionError'}, 'returns': None}, 'offset': 14, 'opr': 'invoke'}
Nb>   LOCALS: [0]
Nb>   STACK: ['new java/lang/AssertionError()', 'new java/lang/AssertionError()']
Nb> STEP 7:
Nb>   PC: 7 {'offset': 17, 'opr': 'throw'}
Nb>   LOCALS: [0]
Nb>   STACK: ['assertion error', 'new java/lang/AssertionError()']
Nb> STEP 8:
Nb>   PC: 8 {'offset': 18, 'opr': 'return', 'type': None}
Nb>   LOCALS: [0]
Nb>   STACK: ['assertion error', 'new java/lang/AssertionError()']
Nb> DONE ok
Nb>   LOCALS: [0]
Nb>   STACK: ['assertion error', 'new java/lang/AssertionError()']
Nb> done
b3> starting: python3 solutions/interpret_week3.py 'jpamb.cases.Simple.assertInteger:(I)V' '(1)'
b3> read decompiled classfile decompiled/jpamb/cases/Simple.json
b3> STEP 0:
b3>   PC: 0 {'field': {'class': 'jpamb/cases/Simple', 'name': '$assertionsDisabled', 'type': 'boolean'}, 'offset': 0, 'opr': 'get', 'static': True}
b3>   LOCALS: [1]
b3>   STACK: []
b3> STEP 1:
b3>   PC: 1 {'condition': 'ne', 'offset': 3, 'opr': 'ifz', 'target': 8}
b3>   LOCALS: [1]
b3>   STACK: [False]
b3> STEP 2:
b3>   PC: 2 {'index': 0, 'offset': 6, 'opr': 'load', 'type': 'int'}
b3>   LOCALS: [1]
b3>   STACK: []
b3> STEP 3:
b3>   PC: 3 {'condition': 'ne', 'offset': 7, 'opr': 'ifz', 'target': 8}
b3>   LOCALS: [1]
b3>   STACK: [1]
b3> STEP 4:
b3>   PC: 8 {'offset': 18, 'opr': 'return', 'type': None}
b3>   LOCALS: [1]
b3>   STACK: []
b3> DONE ok
b3>   LOCALS: [1]
b3>   STACK: []
b3> done
JM> starting: python3 solutions/interpret_week3.py 'jpamb.cases.Simple.assertPositive:(I)V' '(-1)'
JM> read decompiled classfile decompiled/jpamb/cases/Simple.json
JM> STEP 0:
JM>   PC: 0 {'field': {'class': 'jpamb/cases/Simple', 'name': '$assertionsDisabled', 'type': 'boolean'}, 'offset': 0, 'opr': 'get', 'static': True}
JM>   LOCALS: [-1]
JM>   STACK: []
JM> STEP 1:
JM>   PC: 1 {'condition': 'ne', 'offset': 3, 'opr': 'ifz', 'target': 8}
JM>   LOCALS: [-1]
JM>   STACK: [False]
JM> STEP 2:
JM>   PC: 2 {'index': 0, 'offset': 6, 'opr': 'load', 'type': 'int'}
JM>   LOCALS: [-1]
JM>   STACK: []
JM> STEP 3:
JM>   PC: 3 {'condition': 'gt', 'offset': 7, 'opr': 'ifz', 'target': 8}
JM>   LOCALS: [-1]
JM>   STACK: [-1]
JM> STEP 4:
JM>   PC: 4 {'class': 'java/lang/AssertionError', 'offset': 10, 'opr': 'new'}
JM>   LOCALS: [-1]
JM>   STACK: []
JM> STEP 5:
JM>   PC: 5 {'offset': 13, 'opr': 'dup', 'words': 1}
JM>   LOCALS: [-1]
JM>   STACK: ['new java/lang/AssertionError()']
JM> STEP 6:
JM>   PC: 6 {'access': 'special', 'method': {'args': [], 'is_interface': False, 'name': '<init>', 'ref': {'kind': 'class', 'name': 'java/lang/AssertionError'}, 'returns': None}, 'offset': 14, 'opr': 'invoke'}
JM>   LOCALS: [-1]
JM>   STACK: ['new java/lang/AssertionError()', 'new java/lang/AssertionError()']
JM> STEP 7:
JM>   PC: 7 {'offset': 17, 'opr': 'throw'}
JM>   LOCALS: [-1]
JM>   STACK: ['assertion error', 'new java/lang/AssertionError()']
JM> STEP 8:
JM>   PC: 8 {'offset': 18, 'opr': 'return', 'type': None}
JM>   LOCALS: [-1]
JM>   STACK: ['assertion error', 'new java/lang/AssertionError()']
JM> DONE ok
JM>   LOCALS: [-1]
JM>   STACK: ['assertion error', 'new java/lang/AssertionError()']
JM> done
2K> starting: python3 solutions/interpret_week3.py 'jpamb.cases.Simple.assertPositive:(I)V' '(1)'
2K> read decompiled classfile decompiled/jpamb/cases/Simple.json
2K> STEP 0:
2K>   PC: 0 {'field': {'class': 'jpamb/cases/Simple', 'name': '$assertionsDisabled', 'type': 'boolean'}, 'offset': 0, 'opr': 'get', 'static': True}
2K>   LOCALS: [1]
2K>   STACK: []
2K> STEP 1:
2K>   PC: 1 {'condition': 'ne', 'offset': 3, 'opr': 'ifz', 'target': 8}
2K>   LOCALS: [1]
2K>   STACK: [False]
2K> STEP 2:
2K>   PC: 2 {'index': 0, 'offset': 6, 'opr': 'load', 'type': 'int'}
2K>   LOCALS: [1]
2K>   STACK: []
2K> STEP 3:
2K>   PC: 3 {'condition': 'gt', 'offset': 7, 'opr': 'ifz', 'target': 8}
2K>   LOCALS: [1]
2K>   STACK: [1]
2K> STEP 4:
2K>   PC: 8 {'offset': 18, 'opr': 'return', 'type': None}
2K>   LOCALS: [1]
2K>   STACK: []
2K> DONE ok
2K>   LOCALS: [1]
2K>   STACK: []
2K> done
F4> starting: python3 solutions/interpret_week3.py 'jpamb.cases.Simple.checkBeforeAssert:(I)V' '(-1)'
F4> read decompiled classfile decompiled/jpamb/cases/Simple.json
F4> STEP 0:
F4>   PC: 0 {'index': 0, 'offset': 0, 'opr': 'load', 'type': 'int'}
F4>   LOCALS: [-1]
F4>   STACK: []
F4> STEP 1:
F4>   PC: 1 {'condition': 'ne', 'offset': 1, 'opr': 'ifz', 'target': 3}
F4>   LOCALS: [-1]
F4>   STACK: [-1]
F4> STEP 2:
F4>   PC: 3 {'field': {'class': 'jpamb/cases/Simple', 'name': '$assertionsDisabled', 'type': 'boolean'}, 'offset': 5, 'opr': 'get', 'static': True}
F4>   LOCALS: [-1]
F4>   STACK: []
F4> STEP 3:
F4>   PC: 4 {'condition': 'ne', 'offset': 8, 'opr': 'ifz', 'target': 13}
F4>   LOCALS: [-1]
F4>   STACK: [False]
F4> STEP 4:
F4>   PC: 5 {'offset': 11, 'opr': 'push', 'value': {'type': 'integer', 'value': 1}}
F4>   LOCALS: [-1]
F4>   STACK: []
F4> STEP 5:
F4>   PC: 6 {'index': 0, 'offset': 12, 'opr': 'load', 'type': 'int'}
F4>   LOCALS: [-1]
F4>   STACK: [1]
F4> STEP 6:
F4>   PC: 7 {'offset': 13, 'operant': 'div', 'opr': 'binary', 'type': 'int'}
F4>   LOCALS: [-1]
F4>   STACK: [-1, 1]
F4> STEP 7:
F4>   PC: 8 {'condition': 'gt', 'offset': 14, 'opr': 'ifz', 'target': 13}
F4>   LOCALS: [-1]
F4>   STACK: [-1.0]
F4> STEP 8:
F4>   PC: 9 {'class': 'java/lang/AssertionError', 'offset': 17, 'opr': 'new'}
F4>   LOCALS: [-1]
F4>   STACK: []
F4> STEP 9:
F4>   PC: 10 {'offset': 20, 'opr': 'dup', 'words': 1}
F4>   LOCALS: [-1]
F4>   STACK: ['new java/lang/AssertionError()']
F4> STEP 10:
F4>   PC: 11 {'access': 'special', 'method': {'args': [], 'is_interface': False, 'name': '<init>', 'ref': {'kind': 'class', 'name': 'java/lang/AssertionError'}, 'returns': None}, 'offset': 21, 'opr': 'invoke'}
F4>   LOCALS: [-1]
F4>   STACK: ['new java/lang/AssertionError()', 'new java/lang/AssertionError()']
F4> STEP 11:
F4>   PC: 12 {'offset': 24, 'opr': 'throw'}
F4>   LOCALS: [-1]
F4>   STACK: ['assertion error', 'new java/lang/AssertionError()']
F4> STEP 12:
F4>   PC: 13 {'offset': 25, 'opr': 'return', 'type': None}
F4>   LOCALS: [-1]
F4>   STACK: ['assertion error', 'new java/lang/AssertionError()']
F4> DONE ok
F4>   LOCALS: [-1]
F4>   STACK: ['assertion error', 'new java/lang/AssertionError()']
F4> done
AE> starting: python3 solutions/interpret_week3.py 'jpamb.cases.Simple.checkBeforeAssert:(I)V' '(0)'
AE> read decompiled classfile decompiled/jpamb/cases/Simple.json
AE> STEP 0:
AE>   PC: 0 {'index': 0, 'offset': 0, 'opr': 'load', 'type': 'int'}
AE>   LOCALS: [0]
AE>   STACK: []
AE> STEP 1:
AE>   PC: 1 {'condition': 'ne', 'offset': 1, 'opr': 'ifz', 'target': 3}
AE>   LOCALS: [0]
AE>   STACK: [0]
AE> STEP 2:
AE>   PC: 2 {'offset': 4, 'opr': 'return', 'type': None}
AE>   LOCALS: [0]
AE>   STACK: []
AE> DONE ok
AE>   LOCALS: [0]
AE>   STACK: []
AE> done
5J> starting: python3 solutions/interpret_week3.py 'jpamb.cases.Simple.checkBeforeDivideByN2:(I)I' '(0)'
5J> read decompiled classfile decompiled/jpamb/cases/Simple.json
5J> STEP 0:
5J>   PC: 0 {'index': 0, 'offset': 0, 'opr': 'load', 'type': 'int'}
5J>   LOCALS: [0]
5J>   STACK: []
5J> STEP 1:
5J>   PC: 1 {'condition': 'eq', 'offset': 1, 'opr': 'ifz', 'target': 6}
5J>   LOCALS: [0]
5J>   STACK: [0]
5J> STEP 2:
5J>   PC: 6 {'field': {'class': 'jpamb/cases/Simple', 'name': '$assertionsDisabled', 'type': 'boolean'}, 'offset': 8, 'opr': 'get', 'static': True}
5J>   LOCALS: [0]
5J>   STACK: []
5J> STEP 3:
5J>   PC: 7 {'condition': 'ne', 'offset': 11, 'opr': 'ifz', 'target': 15}
5J>   LOCALS: [0]
5J>   STACK: [False]
5J> STEP 4:
5J>   PC: 8 {'offset': 14, 'opr': 'push', 'value': {'type': 'integer', 'value': 10}}
5J>   LOCALS: [0]
5J>   STACK: []
5J> STEP 5:
5J>   PC: 9 {'index': 0, 'offset': 16, 'opr': 'load', 'type': 'int'}
5J>   LOCALS: [0]
5J>   STACK: [10]
5J> STEP 6:
5J>   PC: 10 {'condition': 'gt', 'offset': 17, 'opr': 'if', 'target': 15}
5J>   LOCALS: [0]
5J>   STACK: [0, 10]
5J> STEP 7:
5J>   PC: 15 {'offset': 28, 'opr': 'push', 'value': {'type': 'integer', 'value': 0}}
5J>   LOCALS: [0]
5J>   STACK: []
5J> STEP 8:
5J>   PC: 16 {'offset': 29, 'opr': 'return', 'type': 'int'}
5J>   LOCALS: [0]
5J>   STACK: [0]
5J> DONE ok
5J>   LOCALS: [0]
5J>   STACK: []
5J> done
Zw> starting: python3 solutions/interpret_week3.py 'jpamb.cases.Simple.checkBeforeDivideByN2:(I)I' '(1)'
Zw> read decompiled classfile decompiled/jpamb/cases/Simple.json
Zw> STEP 0:
Zw>   PC: 0 {'index': 0, 'offset': 0, 'opr': 'load', 'type': 'int'}
Zw>   LOCALS: [1]
Zw>   STACK: []
Zw> STEP 1:
Zw>   PC: 1 {'condition': 'eq', 'offset': 1, 'opr': 'ifz', 'target': 6}
Zw>   LOCALS: [1]
Zw>   STACK: [1]
Zw> STEP 2:
Zw>   PC: 2 {'offset': 4, 'opr': 'push', 'value': {'type': 'integer', 'value': 1}}
Zw>   LOCALS: [1]
Zw>   STACK: []
Zw> STEP 3:
Zw>   PC: 3 {'index': 0, 'offset': 5, 'opr': 'load', 'type': 'int'}
Zw>   LOCALS: [1]
Zw>   STACK: [1]
Zw> STEP 4:
Zw>   PC: 4 {'offset': 6, 'operant': 'div', 'opr': 'binary', 'type': 'int'}
Zw>   LOCALS: [1]
Zw>   STACK: [1, 1]
Zw> STEP 5:
Zw>   PC: 5 {'offset': 7, 'opr': 'return', 'type': 'int'}
Zw>   LOCALS: [1]
Zw>   STACK: [1.0]
Zw> DONE ok
Zw>   LOCALS: [1]
Zw>   STACK: []
Zw> done
yn> starting: python3 solutions/interpret_week3.py 'jpamb.cases.Simple.checkBeforeDivideByN:(I)I' '(0)'
yn> read decompiled classfile decompiled/jpamb/cases/Simple.json
yn> STEP 0:
yn>   PC: 0 {'field': {'class': 'jpamb/cases/Simple', 'name': '$assertionsDisabled', 'type': 'boolean'}, 'offset': 0, 'opr': 'get', 'static': True}
yn>   LOCALS: [0]
yn>   STACK: []
yn> STEP 1:
yn>   PC: 1 {'condition': 'ne', 'offset': 3, 'opr': 'ifz', 'target': 8}
yn>   LOCALS: [0]
yn>   STACK: [False]
yn> STEP 2:
yn>   PC: 2 {'index': 0, 'offset': 6, 'opr': 'load', 'type': 'int'}
yn>   LOCALS: [0]
yn>   STACK: []
yn> STEP 3:
yn>   PC: 3 {'condition': 'ne', 'offset': 7, 'opr': 'ifz', 'target': 8}
yn>   LOCALS: [0]
yn>   STACK: [0]
yn> STEP 4:
yn>   PC: 4 {'class': 'java/lang/AssertionError', 'offset': 10, 'opr': 'new'}
yn>   LOCALS: [0]
yn>   STACK: []
yn> STEP 5:
yn>   PC: 5 {'offset': 13, 'opr': 'dup', 'words': 1}
yn>   LOCALS: [0]
yn>   STACK: ['new java/lang/AssertionError()']
yn> STEP 6:
yn>   PC: 6 {'access': 'special', 'method': {'args': [], 'is_interface': False, 'name': '<init>', 'ref': {'kind': 'class', 'name': 'java/lang/AssertionError'}, 'returns': None}, 'offset': 14, 'opr': 'invoke'}
yn>   LOCALS: [0]
yn>   STACK: ['new java/lang/AssertionError()', 'new java/lang/AssertionError()']
yn> STEP 7:
yn>   PC: 7 {'offset': 17, 'opr': 'throw'}
yn>   LOCALS: [0]
yn>   STACK: ['assertion error', 'new java/lang/AssertionError()']
yn> STEP 8:
yn>   PC: 8 {'offset': 18, 'opr': 'push', 'value': {'type': 'integer', 'value': 1}}
yn>   LOCALS: [0]
yn>   STACK: ['assertion error', 'new java/lang/AssertionError()']
yn> STEP 9:
yn>   PC: 9 {'index': 0, 'offset': 19, 'opr': 'load', 'type': 'int'}
yn>   LOCALS: [0]
yn>   STACK: [1, 'assertion error', 'new java/lang/AssertionError()']
yn> STEP 10:
yn>   PC: 10 {'offset': 20, 'operant': 'div', 'opr': 'binary', 'type': 'int'}
yn>   LOCALS: [0]
yn>   STACK: [0, 1, 'assertion error', 'new java/lang/AssertionError()']
yn> DONE divide by zero
yn>   LOCALS: [0]
yn>   STACK: [0, 'assertion error', 'new java/lang/AssertionError()']
yn> done
U/> starting: python3 solutions/interpret_week3.py 'jpamb.cases.Simple.checkBeforeDivideByN:(I)I' '(1)'
U/> read decompiled classfile decompiled/jpamb/cases/Simple.json
U/> STEP 0:
U/>   PC: 0 {'field': {'class': 'jpamb/cases/Simple', 'name': '$assertionsDisabled', 'type': 'boolean'}, 'offset': 0, 'opr': 'get', 'static': True}
U/>   LOCALS: [1]
U/>   STACK: []
U/> STEP 1:
U/>   PC: 1 {'condition': 'ne', 'offset': 3, 'opr': 'ifz', 'target': 8}
U/>   LOCALS: [1]
U/>   STACK: [False]
U/> STEP 2:
U/>   PC: 2 {'index': 0, 'offset': 6, 'opr': 'load', 'type': 'int'}
U/>   LOCALS: [1]
U/>   STACK: []
U/> STEP 3:
U/>   PC: 3 {'condition': 'ne', 'offset': 7, 'opr': 'ifz', 'target': 8}
U/>   LOCALS: [1]
U/>   STACK: [1]
U/> STEP 4:
U/>   PC: 8 {'offset': 18, 'opr': 'push', 'value': {'type': 'integer', 'value': 1}}
U/>   LOCALS: [1]
U/>   STACK: []
U/> STEP 5:
U/>   PC: 9 {'index': 0, 'offset': 19, 'opr': 'load', 'type': 'int'}
U/>   LOCALS: [1]
U/>   STACK: [1]
U/> STEP 6:
U/>   PC: 10 {'offset': 20, 'operant': 'div', 'opr': 'binary', 'type': 'int'}
U/>   LOCALS: [1]
U/>   STACK: [1, 1]
U/> STEP 7:
U/>   PC: 11 {'offset': 21, 'opr': 'return', 'type': 'int'}
U/>   LOCALS: [1]
U/>   STACK: [1.0]
U/> DONE ok
U/>   LOCALS: [1]
U/>   STACK: []
U/> done
bY> starting: python3 solutions/interpret_week3.py 'jpamb.cases.Simple.divideByN:(I)I' '(0)'
bY> read decompiled classfile decompiled/jpamb/cases/Simple.json
bY> STEP 0:
bY>   PC: 0 {'offset': 0, 'opr': 'push', 'value': {'type': 'integer', 'value': 1}}
bY>   LOCALS: [0]
bY>   STACK: []
bY> STEP 1:
bY>   PC: 1 {'index': 0, 'offset': 1, 'opr': 'load', 'type': 'int'}
bY>   LOCALS: [0]
bY>   STACK: [1]
bY> STEP 2:
bY>   PC: 2 {'offset': 2, 'operant': 'div', 'opr': 'binary', 'type': 'int'}
bY>   LOCALS: [0]
bY>   STACK: [0, 1]
bY> DONE divide by zero
bY>   LOCALS: [0]
bY>   STACK: [0]
bY> done
z2> starting: python3 solutions/interpret_week3.py 'jpamb.cases.Simple.divideByN:(I)I' '(1)'
z2> read decompiled classfile decompiled/jpamb/cases/Simple.json
z2> STEP 0:
z2>   PC: 0 {'offset': 0, 'opr': 'push', 'value': {'type': 'integer', 'value': 1}}
z2>   LOCALS: [1]
z2>   STACK: []
z2> STEP 1:
z2>   PC: 1 {'index': 0, 'offset': 1, 'opr': 'load', 'type': 'int'}
z2>   LOCALS: [1]
z2>   STACK: [1]
z2> STEP 2:
z2>   PC: 2 {'offset': 2, 'operant': 'div', 'opr': 'binary', 'type': 'int'}
z2>   LOCALS: [1]
z2>   STACK: [1, 1]
z2> STEP 3:
z2>   PC: 3 {'offset': 3, 'opr': 'return', 'type': 'int'}
z2>   LOCALS: [1]
z2>   STACK: [1.0]
z2> DONE ok
z2>   LOCALS: [1]
z2>   STACK: []
z2> done
S+> starting: python3 solutions/interpret_week3.py 'jpamb.cases.Simple.divideByNMinus10054203:(I)I' '(0)'
S+> read decompiled classfile decompiled/jpamb/cases/Simple.json
S+> STEP 0:
S+>   PC: 0 {'offset': 0, 'opr': 'push', 'value': {'type': 'integer', 'value': 1}}
S+>   LOCALS: [0]
S+>   STACK: []
S+> STEP 1:
S+>   PC: 1 {'index': 0, 'offset': 1, 'opr': 'load', 'type': 'int'}
S+>   LOCALS: [0]
S+>   STACK: [1]
S+> STEP 2:
S+>   PC: 2 {'offset': 2, 'opr': 'push', 'value': {'type': 'integer', 'value': 10054203}}
S+>   LOCALS: [0]
S+>   STACK: [0, 1]
S+> STEP 3:
S+>   PC: 3 {'offset': 4, 'operant': 'sub', 'opr': 'binary', 'type': 'int'}
S+>   LOCALS: [0]
S+>   STACK: [10054203, 0, 1]
S+> STEP 4:
S+>   PC: 4 {'offset': 5, 'operant': 'div', 'opr': 'binary', 'type': 'int'}
S+>   LOCALS: [0]
S+>   STACK: [-10054203, 1]
S+> STEP 5:
S+>   PC: 5 {'offset': 6, 'opr': 'return', 'type': 'int'}
S+>   LOCALS: [0]
S+>   STACK: [-9.946089212640724e-08]
S+> DONE ok
S+>   LOCALS: [0]
S+>   STACK: []
S+> done
cx> starting: python3 solutions/interpret_week3.py 'jpamb.cases.Simple.divideByNMinus10054203:(I)I' '(10054203)'
cx> read decompiled classfile decompiled/jpamb/cases/Simple.json
cx> STEP 0:
cx>   PC: 0 {'offset': 0, 'opr': 'push', 'value': {'type': 'integer', 'value': 1}}
cx>   LOCALS: [10054203]
cx>   STACK: []
cx> STEP 1:
cx>   PC: 1 {'index': 0, 'offset': 1, 'opr': 'load', 'type': 'int'}
cx>   LOCALS: [10054203]
cx>   STACK: [1]
cx> STEP 2:
cx>   PC: 2 {'offset': 2, 'opr': 'push', 'value': {'type': 'integer', 'value': 10054203}}
cx>   LOCALS: [10054203]
cx>   STACK: [10054203, 1]
cx> STEP 3:
cx>   PC: 3 {'offset': 4, 'operant': 'sub', 'opr': 'binary', 'type': 'int'}
cx>   LOCALS: [10054203]
cx>   STACK: [10054203, 10054203, 1]
cx> STEP 4:
cx>   PC: 4 {'offset': 5, 'operant': 'div', 'opr': 'binary', 'type': 'int'}
cx>   LOCALS: [10054203]
cx>   STACK: [0, 1]
cx> DONE divide by zero
cx>   LOCALS: [10054203]
cx>   STACK: [0]
cx> done
cM> starting: python3 solutions/interpret_week3.py 'jpamb.cases.Simple.divideByZero:()I' '()'
cM> read decompiled classfile decompiled/jpamb/cases/Simple.json
cM> STEP 0:
cM>   PC: 0 {'offset': 0, 'opr': 'push', 'value': {'type': 'integer', 'value': 1}}
cM>   LOCALS: []
cM>   STACK: []
cM> STEP 1:
cM>   PC: 1 {'offset': 1, 'opr': 'push', 'value': {'type': 'integer', 'value': 0}}
cM>   LOCALS: []
cM>   STACK: [1]
cM> STEP 2:
cM>   PC: 2 {'offset': 2, 'operant': 'div', 'opr': 'binary', 'type': 'int'}
cM>   LOCALS: []
cM>   STACK: [0, 1]
cM> DONE divide by zero
cM>   LOCALS: []
cM>   STACK: [0]
cM> done
bV> starting: python3 solutions/interpret_week3.py 'jpamb.cases.Simple.divideZeroByZero:(II)I' '(0, 0)'
bV> read decompiled classfile decompiled/jpamb/cases/Simple.json
bV> STEP 0:
bV>   PC: 0 {'index': 0, 'offset': 0, 'opr': 'load', 'type': 'int'}
bV>   LOCALS: [0, 0]
bV>   STACK: []
bV> STEP 1:
bV>   PC: 1 {'index': 1, 'offset': 1, 'opr': 'load', 'type': 'int'}
bV>   LOCALS: [0, 0]
bV>   STACK: [0]
bV> STEP 2:
bV>   PC: 2 {'offset': 2, 'operant': 'div', 'opr': 'binary', 'type': 'int'}
bV>   LOCALS: [0, 0]
bV>   STACK: [0, 0]
bV> DONE divide by zero
bV>   LOCALS: [0, 0]
bV>   STACK: [0]
bV> done
tk> starting: python3 solutions/interpret_week3.py 'jpamb.cases.Simple.divideZeroByZero:(II)I' '(0, 1)'
tk> read decompiled classfile decompiled/jpamb/cases/Simple.json
tk> STEP 0:
tk>   PC: 0 {'index': 0, 'offset': 0, 'opr': 'load', 'type': 'int'}
tk>   LOCALS: [0, 1]
tk>   STACK: []
tk> STEP 1:
tk>   PC: 1 {'index': 1, 'offset': 1, 'opr': 'load', 'type': 'int'}
tk>   LOCALS: [0, 1]
tk>   STACK: [0]
tk> STEP 2:
tk>   PC: 2 {'offset': 2, 'operant': 'div', 'opr': 'binary', 'type': 'int'}
tk>   LOCALS: [0, 1]
tk>   STACK: [1, 0]
tk> STEP 3:
tk>   PC: 3 {'offset': 3, 'opr': 'return', 'type': 'int'}
tk>   LOCALS: [0, 1]
tk>   STACK: [0.0]
tk> DONE ok
tk>   LOCALS: [0, 1]
tk>   STACK: []
tk> done
Tv> starting: python3 solutions/interpret_week3.py 'jpamb.cases.Simple.earlyReturn:()I' '()'
Tv> read decompiled classfile decompiled/jpamb/cases/Simple.json
Tv> STEP 0:
Tv>   PC: 0 {'offset': 0, 'opr': 'push', 'value': {'type': 'integer', 'value': 0}}
Tv>   LOCALS: []
Tv>   STACK: []
Tv> STEP 1:
Tv>   PC: 1 {'offset': 1, 'opr': 'return', 'type': 'int'}
Tv>   LOCALS: []
Tv>   STACK: [0]
Tv> DONE ok
Tv>   LOCALS: []
Tv>   STACK: []
Tv> done
0w> starting: python3 solutions/interpret_week3.py 'jpamb.cases.Simple.justReturn:()I' '()'
0w> read decompiled classfile decompiled/jpamb/cases/Simple.json
0w> STEP 0:
0w>   PC: 0 {'offset': 0, 'opr': 'push', 'value': {'type': 'integer', 'value': 0}}
0w>   LOCALS: []
0w>   STACK: []
0w> STEP 1:
0w>   PC: 1 {'offset': 1, 'opr': 'return', 'type': 'int'}
0w>   LOCALS: []
0w>   STACK: [0]
0w> DONE ok
0w>   LOCALS: []
0w>   STACK: []
0w> done
b8> starting: python3 solutions/interpret_week3.py 'jpamb.cases.Simple.justReturnNothing:()V' '()'
b8> read decompiled classfile decompiled/jpamb/cases/Simple.json
b8> STEP 0:
b8>   PC: 0 {'offset': 0, 'opr': 'return', 'type': None}
b8>   LOCALS: []
b8>   STACK: []
b8> DONE ok
b8>   LOCALS: []
b8>   STACK: []
b8> done
uT> starting: python3 solutions/interpret_week3.py 'jpamb.cases.Simple.multiError:(Z)I' '(false)'
uT> read decompiled classfile decompiled/jpamb/cases/Simple.json
uT> STEP 0:
uT>   PC: 0 {'field': {'class': 'jpamb/cases/Simple', 'name': '$assertionsDisabled', 'type': 'boolean'}, 'offset': 0, 'opr': 'get', 'static': True}
uT>   LOCALS: [False]
uT>   STACK: []
uT> STEP 1:
uT>   PC: 1 {'condition': 'ne', 'offset': 3, 'opr': 'ifz', 'target': 8}
uT>   LOCALS: [False]
uT>   STACK: [False]
uT> STEP 2:
uT>   PC: 2 {'index': 0, 'offset': 6, 'opr': 'load', 'type': 'int'}
uT>   LOCALS: [False]
uT>   STACK: []
uT> STEP 3:
uT>   PC: 3 {'condition': 'ne', 'offset': 7, 'opr': 'ifz', 'target': 8}
uT>   LOCALS: [False]
uT>   STACK: [False]
uT> STEP 4:
uT>   PC: 4 {'class': 'java/lang/AssertionError', 'offset': 10, 'opr': 'new'}
uT>   LOCALS: [False]
uT>   STACK: []
uT> STEP 5:
uT>   PC: 5 {'offset': 13, 'opr': 'dup', 'words': 1}
uT>   LOCALS: [False]
uT>   STACK: ['new java/lang/AssertionError()']
uT> STEP 6:
uT>   PC: 6 {'access': 'special', 'method': {'args': [], 'is_interface': False, 'name': '<init>', 'ref': {'kind': 'class', 'name': 'java/lang/AssertionError'}, 'returns': None}, 'offset': 14, 'opr': 'invoke'}
uT>   LOCALS: [False]
uT>   STACK: ['new java/lang/AssertionError()', 'new java/lang/AssertionError()']
uT> STEP 7:
uT>   PC: 7 {'offset': 17, 'opr': 'throw'}
uT>   LOCALS: [False]
uT>   STACK: ['assertion error', 'new java/lang/AssertionError()']
uT> STEP 8:
uT>   PC: 8 {'offset': 18, 'opr': 'push', 'value': {'type': 'integer', 'value': 1}}
uT>   LOCALS: [False]
uT>   STACK: ['assertion error', 'new java/lang/AssertionError()']
uT> STEP 9:
uT>   PC: 9 {'offset': 19, 'opr': 'push', 'value': {'type': 'integer', 'value': 0}}
uT>   LOCALS: [False]
uT>   STACK: [1, 'assertion error', 'new java/lang/AssertionError()']
uT> STEP 10:
uT>   PC: 10 {'offset': 20, 'operant': 'div', 'opr': 'binary', 'type': 'int'}
uT>   LOCALS: [False]
uT>   STACK: [0, 1, 'assertion error', 'new java/lang/AssertionError()']
uT> DONE divide by zero
uT>   LOCALS: [False]
uT>   STACK: [0, 'assertion error', 'new java/lang/AssertionError()']
uT> done
Ig> starting: python3 solutions/interpret_week3.py 'jpamb.cases.Simple.multiError:(Z)I' '(true)'
Ig> read decompiled classfile decompiled/jpamb/cases/Simple.json
Ig> STEP 0:
Ig>   PC: 0 {'field': {'class': 'jpamb/cases/Simple', 'name': '$assertionsDisabled', 'type': 'boolean'}, 'offset': 0, 'opr': 'get', 'static': True}
Ig>   LOCALS: [True]
Ig>   STACK: []
Ig> STEP 1:
Ig>   PC: 1 {'condition': 'ne', 'offset': 3, 'opr': 'ifz', 'target': 8}
Ig>   LOCALS: [True]
Ig>   STACK: [False]
Ig> STEP 2:
Ig>   PC: 2 {'index': 0, 'offset': 6, 'opr': 'load', 'type': 'int'}
Ig>   LOCALS: [True]
Ig>   STACK: []
Ig> STEP 3:
Ig>   PC: 3 {'condition': 'ne', 'offset': 7, 'opr': 'ifz', 'target': 8}
Ig>   LOCALS: [True]
Ig>   STACK: [True]
Ig> STEP 4:
Ig>   PC: 8 {'offset': 18, 'opr': 'push', 'value': {'type': 'integer', 'value': 1}}
Ig>   LOCALS: [True]
Ig>   STACK: []
Ig> STEP 5:
Ig>   PC: 9 {'offset': 19, 'opr': 'push', 'value': {'type': 'integer', 'value': 0}}
Ig>   LOCALS: [True]
Ig>   STACK: [1]
Ig> STEP 6:
Ig>   PC: 10 {'offset': 20, 'operant': 'div', 'opr': 'binary', 'type': 'int'}
Ig>   LOCALS: [True]
Ig>   STACK: [0, 1]
Ig> DONE divide by zero
Ig>   LOCALS: [True]
Ig>   STACK: [0]
Ig> done
